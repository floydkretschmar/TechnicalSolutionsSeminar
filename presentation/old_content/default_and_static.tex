
\begin{frame}[fragile]{Standard-Methoden für Interfaces}
    \begin{itemize}
        \item<1-> \textbf{Ziel:} Integration neuer Lambda-Funktionalität in vorhandene 
        Frameworks
        \item<2-> \textbf{Problem:} Erweiterung von bereits existierenden Interfaces oder
        abstrakten Basisklassen problematisch
        \item[$\rightarrow$]<3-> \texttt{default}-Methoden, die das \enquote{Standardverhalten}
        des Interfaces festlegen  
    \end{itemize}

    \pause\pause

    \begin{center}
        \begin{minipage}[b]{0.75\textwidth}
            \begin{block}{\texttt{default}-Methode \citep{goetz13}}
                \begin{lstlisting}  
interface Iterator<E> {
    boolean hasNext();
    E next();
    void remove();

    default void skip(int i) {
        for (; i > 0 && hasNext(); i--) next();
    }
}
                \end{lstlisting}
            \end{block}
        \end{minipage}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Ableiten von Standard-Methoden}
    \begin{itemize}
        \item<1-> Ableitungsregeln äquivalent zu anderen Methoden
        \item<2-> \textbf{Problem:} Konfliktpotential wenn mehrere Supertypen 
        \texttt{default}-Methoden mit identischer Signatur definieren
        \item<3-> Compiler versucht Konflikt aufzulösen, ansonsten Fehler beim kompilieren
        \item[$\rightarrow$]<4-> Programmierer wählt bevorzugte Implementierung aus entsprechendem 
        Supertypen  
    \end{itemize}

    \begin{onlyenv}<4->
        \begin{center}
            \begin{minipage}[b]{0.75\textwidth}
                \begin{block}{Neue \texttt{super}-Syntax \citep{goetz13}}
                    \begin{lstlisting}
interface Robot implements Artist, Gun {
    default void draw() { Artist.super.draw(); }
}
                    \end{lstlisting}
                \end{block}
            \end{minipage}
        \end{center}
    \end{onlyenv}
\end{frame}


\begin{frame}[fragile]{Ableiten von Standard-Methoden}
    \begin{itemize}
        \item Klassenmethoden haben Priorität vor Interface-Methoden \pause
        \item Interface-Methoden die bereits einmal überschrieben wurden, werden vom
        Compiler ignoriert \pause
    \end{itemize}

    \begin{center}
        \begin{minipage}[b]{0.75\textwidth}
            \begin{block}{Behandlung von Ableitungskonflikten \citep{Gallardo14}}
                \begin{lstlisting}  
public interface Animal {
    default public String identifyMyself() {
        return "I am an animal.";
    }
}
public interface EggLayer extends Animal {
    default public String identifyMyself() {
        return "I am able to lay eggs.";
    }
}
public interface FireBreather extends Animal {}
public class Dragon implements EggLayer, FireBreather {}
                \end{lstlisting}
            \end{block}
        \end{minipage}
    \end{center}
\end{frame}

\begin{frame}[fragile]{Statische Interface-Methoden}
    \begin{itemize}
        \item Funktionalität, die auf allen Instanzen zur Verfügung stehen soll \pause
        \\ $\rightarrow$ \only<2>{Klassenmethode} \pause \only<3->{\textcolor{dkred!70}{\texttt{default}-Methode}} \pause
        \item Funktionalität, die nicht Instanz-spezifisch ist \pause
        \\ $\rightarrow$ \only<5>{statische Klassenmethode} \pause \only<6->{\textcolor{dkred!70}{statische Interface-Methode}} \pause
    \end{itemize}

    \begin{center}
        \begin{minipage}[b]{0.75\textwidth}
            \begin{block}{\texttt{default}-Methode \citep{goetz13}}
                \begin{lstlisting}  
public static <...> Comparator<T> comparing(
    Function<T, U> keyExtractor) {
    return (c1, c2) -> keyExtractor
                        .apply(c1)
                        .compareTo(keyExtractor.apply(c2));
}
                \end{lstlisting}
            \end{block}
        \end{minipage}
    \end{center}

    $\rightarrow$ Reduziert Notwendigkeit für Nebenklassen, die als Sammlung von statischen
    Methoden fungieren
\end{frame}