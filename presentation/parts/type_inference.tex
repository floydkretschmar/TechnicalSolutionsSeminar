\begin{frame}[fragile]{Typ-Inferenz und Zieltypisierung}

    \begin{center}
        \begin{minipage}[b]{0.75\textwidth}
            \begin{block}{Typisierung eines Lambda-Ausdrucks \citep{goetz13}}
                    \begin{lstlisting}
%\textcolor<3->{dkred!70}{ActionListener}% l %\textcolor<3->{dkgreen!70}{=}% e -> ui.dazzle(e.getModifiers())
                    \end{lstlisting}
            \end{block}
        \end{minipage}
    \end{center}

    
    \begin{itemize}
        \item<2-> Name des Funktions-Interfaces wird nicht explizit angegeben
        \item<3-> Compiler versucht den \textcolor{dkred!70}{\textbf{Zieltyp}} dynamisch anhand des 
        \textcolor{dkgreen!70}{\textbf{Programmkontextes}} zu inferieren
    \end{itemize}
\end{frame}


\begin{frame}[fragile]{Typ-Inferenz und Zieltypisierung}{Kompatibilitätschecks}
    Nicht jeder Labda-Ausdruck ist kompatibel mit jedem Funktions-Interface\\
    $\rightarrow$ der Compiler führt bestimmte Kompatibilitätschecks durch
    \begin{itemize}
        \item<2-> Zieltyp \texttt{T} ist ein Funktions-Interface
        \item<3-> Lambda-Ausdruck hat die selbe Anzahl und Art von Parametern wie \texttt{T}
        \item<4-> jeder zurückgegeben Ausdruck ist kompatibel mit dem definierten Rückgabewert von \texttt{T}
        \item<5-> jede geworfene Exception ist kompatibel mit den definierten Exceptions von \texttt{T}
    \end{itemize}
\end{frame}



\begin{frame}[fragile]{Typ-Inferenz und Zieltypisierung}{Kontext für Typ-Inferenz}
    Verschiedene Programmkontexte erfordern unterschiedliche Inferenzregeln für den Compiler:

    \begin{center}
        \begin{minipage}[b]{0.75\textwidth}
            \begin{onlyenv}<2-3>
                \begin{block}{Zuweisungen und return-Anweisungen \citep{goetz13}}
                    \begin{lstlisting}
Comparator<String> c;
c = (String s1, String s2) -> s1.compareToIgnoreCase(s2);

public Runnable toDoLater() {
    return () -> {
        System.out.println("later");
    };
}
                    \end{lstlisting}
                \end{block}
            \end{onlyenv}
            \begin{onlyenv}<4-5>
                \begin{block}{Array-Initialisierung \citep{goetz13}}
                    \begin{lstlisting}
filterFiles(
    new FileFilter[] {
        f -> f.exists(), f -> f.canRead(), f -> f.getName().startsWith("q")
    }
);
                    \end{lstlisting}
                \end{block}
            \end{onlyenv}
            \begin{onlyenv}<6-7>
                \begin{block}{Körper von Lambda-Ausdrücken \citep{goetz13}}
                    \begin{lstlisting}
Supplier<Runnable> c = () -> () -> { System.out.println("hi"); };
                    \end{lstlisting}
                \end{block}
            \end{onlyenv}
            \begin{onlyenv}<8-9>
                \begin{block}{Bedingte Ausdrücke \citep{goetz13}}
                    \begin{lstlisting}
Callable<Integer> c = flag ? (() -> 23) : (() -> 42);
                    \end{lstlisting}
                \end{block}
            \end{onlyenv}
            \begin{onlyenv}<10-11>
                \begin{block}{Casting \citep{goetz13}}
                    \begin{lstlisting}
// Illegal: Object o = () -> { System.out.println("hi"); };
Object o = (Runnable) () -> { System.out.println("hi"); };
                    \end{lstlisting}
                \end{block}
            \end{onlyenv}
            \begin{onlyenv}<12->
                \begin{block}{Parameter einer Methode \citep{goetz13}}
                    \begin{lstlisting}
List<Person> ps = ...
Stream<String> names = ps.stream().map(p -> p.getName());
                    \end{lstlisting}
                \end{block}
            \end{onlyenv}
        \end{minipage}
    \end{center}

    \begin{onlyenv}<3>
        $\rightarrow$ Typ \texttt{T} ist vom selben Typ wie die Zuweisung/der 
        zurückgegebene Wert
    \end{onlyenv}
    \begin{onlyenv}<5>
        $\rightarrow$ Typ \texttt{T} wird abgeleitet vom Array-Typ
    \end{onlyenv}
    \begin{onlyenv}<7>
        $\rightarrow$ Innerer Typ \texttt{T} wird vom äußeren Zieltyp abgeleitet 
    \end{onlyenv}
    \begin{onlyenv}<9>
        $\rightarrow$ Typ \texttt{T} wird von bedingtem Ausdruck \enquote{weitergeleitet}
    \end{onlyenv}
    \begin{onlyenv}<11>
        $\rightarrow$ Typ \texttt{T} durch Cast-Operator festgelegt
    \end{onlyenv}
    \begin{onlyenv}<13->
        \begin{itemize}
            \item<13-> Kompliziertester Fall: Kompatibilität zu Methoden-Überladung und Typ-Inferenz 
            für Parameter muss gewährleistet sein\\
            \item<14-> Compiler nutzt Wissen über den Lambda-Ausdruck um Typ \texttt{T} zu
            inferieren:
            \begin{itemize}
                \item<15-> \textbf{explizite Typisierung:} Compiler kennt Parameter-Typen und 
                return-Typ
                \item<16-> \textbf{implizite Typisierung:} Compiler beachtet ausschließlich 
                Anzahl der Parameter des Lambda-Ausdrucks
            \end{itemize}
        \end{itemize}
    \end{onlyenv}
\end{frame}

